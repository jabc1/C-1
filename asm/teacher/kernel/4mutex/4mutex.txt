进程管理
===========
1. 什么是进程
--------------
	. task/pthread
	. 内核中只有线程(task)

2. 进程的数据结构
----------------	
	struct task_struct;

3. 管理进程
------------
	. 双向循环链表

	. 取得进程描述符
		方法一:
		get_current
			current_thread_info()->task
				sp & ~(THREAD_SIZE - 1) (thread_info)	
		方法二:
			current	

	. 遍历进程家族树			
			current->parent

4. 进程的状态
------------
	. 准备状态
	. 运行状态
	. 停止状态
	. 挂起状态

5. 进程创建
-----------
	. 创建(kernel/fork.c)
		fork->clone->sys_fork->do_fork->copy_process

	. 写时拷贝

进程调度
===========
	. 进程类型
		. I/O消耗型 - 小
		. cpu消耗型 - 大

		. mplayer
			. play(解码)
			. 响应input

	. 时间片
		. 宏观并发，微观串行的效果


内核编程注意事项
================
. libc
. gnuc
. stack 8k
. 浮点
. __usr 检查
. __foo
. 时刻注意并发与竞态



内核中的同步机制 -- 并发与竞态
==============================
. 并发
. 竞态

单cpu无抢占式内核情景
---------------------
	. 进程与进程之间
		不用互斥

	. 进程与中断之间
		local_irq_disable();
		...
		local_irq_enable();


单cpu抢占式内核情景
---------------------
. 配置抢占内核
	make menuconfig
	--------------
	General setup  ---> 
		[*] Prompt for development and/or incomplete code/drivers  

	Kernel Features  ---> 
		[*] Preemptible Kernel (EXPERIMENTAL) 

	--------------
. 进程与进程之间
	preempt_disable();
	...
	preempt_enable();

. 进程与进程和中断之间

	local_irq_disable();
	preempt_disable();
	...
	preempt_enable();
	local_irq_enable();


SMP -- 多cpu非抢占式内核情景
---------------------------
. 进程与进程之间
	spin_lock
	...
	spin_unlock
	
. 进程与进程和中断之间
	spin_lock(key)
	local_irq_disable();
	...
	spin_unlock(key);
	local_irq_enable();

	do_irq()
	{
		spin_lock(key_irq);

		spin_unlock(key_irq);
	}

SMP -- 多cpu抢占式内核情景
---------------------------
. 进程与进程之间
	spin_lock
	preempt_disable();
	...
	preempt_enable();
	spin_unlock

. 进程与进程和中断之间
	spin_lock(key)
	local_irq_disable();
	preempt_disable();
	...
	preempt_enable();
	spin_unlock(key);
	local_irq_enable();

	do_irq()
	{
		spin_lock(key_irq);

		spin_unlock(key_irq);
	}

. 代码模板	



自旋锁
======
#include <linux/spinlock.h>
 //init
spinlock_t key;
spin_lock_init(&key);


 //互斥
spin_lock(&key);        
 //临界区
spin_unlock(&key);      

本质
----
. cpu 轮询

信号量
======
#include <linux/semaphore.h>

struct semaphore sem;
sema_init(&sem, 1);

if(down_interruptible(&sem))
	return -ERESTARTSYS;
//...
up(&sem);


本质
----
. 睡眠等待

skill
-----
#define init_MUTEX(sem)         sema_init(sem, 1)	//互斥
#define init_MUTEX_LOCKED(sem)  sema_init(sem, 0)	//通知

spin_lock PK semaphore
======================
. 返回效率
	spin_lock -- 快
	semaphore -- 慢

. 对cpu的消耗
	spin_lock -- 高
	semaphore -- 低

. 临界区
	spin_lock 
		. 锁的颗粒度小	
		. 不能睡眠
			. sleep
			. schedule
			. 慢I/O(copy_xxx_user)
			. sema

	semaphore 
		. 锁的颗粒度大


. 不能用
	semaphore
		. 在中断里面
	
. 在中断里面只能用spin_lock
	
其他的锁机制
==============
互斥量
-----
mutex

完成量
------
complete

读写锁/读写信号量
------------------
rwlock_t

顺序锁
------
linux/seqlock.h

RCU锁
-------
read copy update

原子变量
=========
. 用于原子操作的变量
. asm/atomic.h

. old
	int a;

	lock
	a = 99;
	unlock

	lock
	a = a + 3;
	unlock

. 原子操作
	atomic_t  a = ATOMIC_INIT(0);
	atomic_set(&a, 99);
	atomic_add(3, &a);

有关知识
========
volatile
---------
	. c 语言
	. __volatile__ __asm__ ()


内存屏蔽
-------
mb();
rmb();
wmb();





